var L=Object.defineProperty;var s=(n,D)=>L(n,"name",{value:D,configurable:true});import{c as _}from"./createLazyWrapper-AC75M60Y.js";import{j as z}from"./jsx-runtime-CGXnEs--.js";import{r as t}from"./index-DGnhqvo7.js";import{D as C,a as b}from"./Drawer.stories-CkqY3IaM.js";import"./_commonjsHelpers-DRKe4gOT.js";import"./iframe-DRVrrpfy.js";import"../sb-preview/runtime.js";import"./createIsland-fzL0F2Ul.js";import"./bem-DSWMYwqE.js";import"./validations-hwxYw-LN.js";import"./Button-BzJ3hXkb.js";import"./Link.server-jBGsbMZ1.js";import"./BaseLink.server-DBk24ESO.js";import"./Icon-PVOdNuED.js";import"./Headline-D7h9gw8y.js";import"./AnimatedText-Dq31sNPj.js";function A({open:n=false,closeOnBackdropClick:D=true,onChange:d,...k},R){const f=t.useRef(null);const v=t.useRef(null);const w=t.useRef(null);const[o,m]=t.useState(()=>Boolean(n));const[p,u]=t.useState(()=>Boolean(n));t.useLayoutEffect(()=>{if(!n){m(false);u(false)}},[n]);t.useEffect(()=>{if(n){f.current=document.activeElement;if(!p)u(true);requestAnimationFrame(()=>{requestAnimationFrame(()=>{var e;(e=w.current)==null?void 0:e.getBoundingClientRect();m(true)})})}else{m(false)}},[n,p]);t.useEffect(()=>{if(o||!p)return;const e=w.current;if(!e){u(false);return}const r=s(l=>{var i,E;if(l.target!==e)return;e.removeEventListener("transitionend",r);u(false);(E=(i=f.current)==null?void 0:i.focus)==null?void 0:E.call(i)},"onEnd");e.addEventListener("transitionend",r);const a=setTimeout(()=>{var l,i;e.removeEventListener("transitionend",r);u(false);(i=(l=f.current)==null?void 0:l.focus)==null?void 0:i.call(l)},450);return()=>{e.removeEventListener("transitionend",r);clearTimeout(a)}},[o,p]);const c=t.useCallback(e=>{var r,a;m(false);d==null?void 0:d({},e??"backdropClick");(a=(r=f.current)==null?void 0:r.focus)==null?void 0:a.call(r)},[d]);t.useEffect(()=>{if(!o)return;const e=s(r=>{if(r.key==="Escape"){r.preventDefault();c("escapeKeyDown")}},"onKey");window.addEventListener("keydown",e);return()=>window.removeEventListener("keydown",e)},[o,c]);t.useEffect(()=>{if(!o)return;const e=requestAnimationFrame(()=>{var r,a;(a=(r=v.current)==null?void 0:r.focus)==null?void 0:a.call(r)});return()=>cancelAnimationFrame(e)},[o]);const y=t.useCallback(()=>{f.current=document.activeElement;u(true);requestAnimationFrame(()=>{requestAnimationFrame(()=>{var e;(e=w.current)==null?void 0:e.getBoundingClientRect();m(true)})})},[]);t.useImperativeHandle(R,()=>({openDrawer:y,closeDrawer:c}),[y,c]);if(!p)return null;return z.jsx(C,{...k,closeButtonRef:v,containerRef:w,open:o,backdropProps:{onMouseDown:s(()=>{if(o&&D){c("backdropClick")}},"onMouseDown")},onClose:c,onMouseDown:s(e=>e.stopPropagation(),"onMouseDown")})}s(A,"DrawerClient");const F=t.forwardRef(A);const h=_({name:"Drawer",Client:F,Server:b,isInteractive:s(()=>true,"isInteractive")});try{Drawerlazy.displayName="Drawerlazy";Drawerlazy.__docgenInfo={"description":"We wrap DrawerClient/DrawerServer in a LazyWrapper,\nso that on the server we render <DrawerServer>, but\non the client we hydrate into <DrawerClient>.","displayName":"Drawerlazy","props":{}}}catch(n){}export{h as default};
